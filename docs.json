[{"name":"Problem","comment":" Let's formalize the problem!\n\nIn order to solve our problem with this library, we need to formalize it using the following three concepts:\n\n  - The **initial state** of the problem.\n  - The **actions** that are available from the initial state. These actions lead us to new exciting states. And then from these new states there might be more actions, leading us to even more states. This can go on further and further.\n  - A **goal test** that tells us when we have reached a solution.\n\nThis all sounds very abstract, so I recommend checking out some examples from the [`Problem.Example`](Problem-Example) module.\n\n@docs Problem\n\nThat's it! Once we have specified all these parameters, the algorithms from [`Problem.Search`](Problem-Search) will solve our problem for us (or at least try their best).\n\n","unions":[],"aliases":[{"name":"Problem","comment":" We use the `Problem` type to formalize our problem. We can then use the search algorithms in [`Problem.Search`](Problem-Search) to search for a solution to the `Problem`.\n\nFirst, we need to think of a suitable data structure to represent the states that can occur in our problem. Then, we can think of the parameters that are necessary to formalize our problem:\n\n\n## `initialState`\n\nSimply the initial state from where we start exploring solutions.\n\n\n## `actions`\n\nActions explain which states are reachable from any given state. Each action consists of a`result`, that is the state which is reached by the action, and of a`stepCost` between the current state and the result state.\n\nFor example, in some route-finding problem there might exist direct connections from Abuja to Accra (933 kilometers) and from Abuja to Lagos (536 kilometers). We could formalize these facts like so:\n\n    actions =\n        \\state ->\n            [ ( \"Abuja\"\n              , [ { state = \"Accra\", stepCost = 933 }\n                , { state = \"Lagos\", stepCost = 536 }\n                ]\n              )\n            , -- more connections, starting at other cities\n              Debug.todo\n            ]\n                |> Dict.fromList\n                |> Dict.get state\n                |> Maybe.withDefault []\n\nFor toy problems, the step cost of every step will often be `1`; Any action takes some effort, but the effort is always the same:\n\n    stepCost =\n        \\_ -> 1\n\nSometimes, we do not care at all about how many steps are taken to solve a problem:\n\n    stepCost =\n        \\_ -> 0\n\nYou might be worrying about avoiding redundant states. That is very reasonable, but don't worry! The search algorithms will avoid them automatically, in a smart way.\n\n\n## `goalTest`\n\nDescribes under which conditions a state is a solution to the problem.\n\nSometimes we know exactly which state is a solution. Thus, if our goal state is Abidjan:\n\n    goalTest =\n        (==) \"Abidjan\"\n\nBut at other times we only know which conditions to pose, so we will write a more sophisticated function here.\n\n\n## `heuristic`\n\nA heuristic is an estimate about the path cost (the sum of step costs of all actions involved) between a state and the nearest goal state.\n\nIf we can think of such an estimate, this is great, because we can then use faster search algorithms ­— `greedySearch` and `bestFirstSearch`!\n\nOften, however, we do not know a heuristic. In that case:\n\n    heuristic =\n        \\_ -> 0\n\n(Or choose any other arbitrary fixed value instead of `0`).\n\n\n## `stateToString`\n\nA function that _uniquely (!)_ converts any state to a string. It will be used for some optimizations.\n\nFor prototyping, we can just use:\n\n    stateToString =\n        Debug.toString\n\nOtherwise, we will need to come up with a custom function. [JSON encoders](https://package.elm-lang.org/packages/elm/json/latest/Json-Encode) might be helpful for coverting more complex states to strings.\n\nThis parameter may appear a bit tedious, but it is necessary for two different kinds of optimizations:\n\n1.  Using [keyed nodes](https://guide.elm-lang.org/optimization/keyed.html) in visualizations. This needs a `String` state representation.\n\n2.  Storing states in dictionaries to access them in logarithmic rather than linear time. This needs a `comparable` state representation. As a `String` happens to be `comparable`, there is no need for a separate `stateToComparable` function.\n\nThere are reasons why `Debug.toString` cannot be part of published packages, so the stringification needs to be done by the library user, sorry.\n\n","args":["state"],"type":"{ initialState : state, actions : state -> List.List { stepCost : Basics.Float, result : state }, goalTest : state -> Basics.Bool, heuristic : state -> Basics.Float, stateToString : state -> String.String }"}],"values":[],"binops":[]}]